Object subclass: #Reservation	instanceVariableNames: 'start end room purpose user approvalStatus'	classVariableNames: ''	poolDictionaries: ''	category: 'Reservations'!!Reservation commentStamp: 'KonstaS 12/14/2019 15:17' prior: 0!I'm a reservation. I specify reservations start and end time. You book a room with me, or use me in a search (for free rooms). !!Reservation methodsFor: 'status' stamp: 'KonstaS 12/14/2019 01:55'!isPending	"Check whether the reservation is pending"	^(approvalStatus == #pending)! !!Reservation methodsFor: 'status' stamp: 'KonstaS 12/14/2019 01:52'!canBe: aSymbol	"can this reservation have its approvalStatus changed to aSymbol ?"	|oldStatus return|	oldStatus := approvalStatus.	approvalStatus := aSymbol.		return := (self room) doesNotHaveConflictingReservationWith: self.		approvalStatus := oldStatus.		^return.! !!Reservation methodsFor: 'status' stamp: 'KonstaS 12/14/2019 01:54'!isAccepted	"Check wether the reservation is accepted"	^(approvalStatus == #accepted)! !!Reservation methodsFor: 'status' stamp: 'KonstaS 12/14/2019 01:55'!setPending	"Sets a reservation as pending"	approvalStatus := #pending! !!Reservation methodsFor: 'status' stamp: 'KonstaS 12/14/2019 01:53'!canBeAccepted	"can this reservation be accepted?"	^self canBe: #accepted.! !!Reservation methodsFor: 'status' stamp: 'KonstaS 12/14/2019 01:55'!isDenied	"Check wether the reservation is denied"	^(approvalStatus == #denied)! !!Reservation methodsFor: 'status' stamp: 'KonstaS 12/14/2019 01:54'!deny	"Denies a reservation"	approvalStatus := #denied! !!Reservation methodsFor: 'status' stamp: 'KonstaS 12/14/2019 00:42'!accept	"Accepts a reservation"	approvalStatus := #accepted! !!Reservation methodsFor: 'status' stamp: 'KonstaS 12/14/2019 01:54'!canBePending	"can this reservation be pending?"	^self canBe: #pending.! !!Reservation methodsFor: 'printing' stamp: 'KonstaS 12/14/2019 00:40'!printOn: aStream	start printOn: aStream! !!Reservation methodsFor: 'ansi protocol' stamp: 'KonstaS 12/14/2019 10:04'!<= comparand	"A reservation is defined <= another one if it starts earlier or at the same time"		^ self start <= comparand start! !!Reservation methodsFor: 'accesing' stamp: 'KonstaS 12/14/2019 10:00'!start: aDateAndTime	"the time when the reservation begins"	start := aDateAndTime! !!Reservation methodsFor: 'accesing' stamp: 'KonstaS 12/14/2019 09:59'!purpose: aPurpose	"The justification the user gave for this reservation"	purpose := aPurpose.! !!Reservation methodsFor: 'accesing' stamp: 'KonstaS 12/14/2019 10:00'!start	"the time when the reservation begins"	^start! !!Reservation methodsFor: 'accesing' stamp: 'KonstaS 12/14/2019 01:58'!end: aDateAndTime	"the time when the reservation ends"	end := aDateAndTime! !!Reservation methodsFor: 'accesing' stamp: 'KonstaS 12/14/2019 10:01'!user: aUser	"the user that made the reservation"	user := aUser! !!Reservation methodsFor: 'accesing' stamp: 'KonstaS 12/14/2019 09:58'!purpose	"The justification the user gave for this reservation"	^purpose.! !!Reservation methodsFor: 'accesing' stamp: 'KonstaS 12/14/2019 01:57'!end	"the time when the reservation ends"	^end! !!Reservation methodsFor: 'accesing' stamp: 'KonstaS 12/14/2019 09:59'!room	"the reservation is a reservation of this room"	^room! !!Reservation methodsFor: 'accesing' stamp: 'KonstaS 12/14/2019 10:00'!user	"the user that made the reservation"	^user! !!Reservation methodsFor: 'accesing' stamp: 'KonstaS 12/14/2019 09:59'!room: aRoom	"the reservation is a reservation of this room"	room := aRoom! !!Reservation methodsFor: 'removing' stamp: 'KonstaS 12/14/2019 10:02'!cancel	"asks to be removed from the room reservation list"		room cancelReservation: self! !!Reservation methodsFor: 'comparing' stamp: 'KonstaS 12/14/2019 00:22'!conflictsWith: aReservation	"Checks if aReservation conflicts with myself"	| a b c d |		"a reservation should not conflict with itself (otherwise, changing status is a pain)"	(aReservation == self)		ifTrue: [ ^ false ].		(aReservation isDenied or: [self isDenied])		ifTrue: [ ^ false ].		a := start.	b := end.	c := aReservation start.	d := aReservation end.		^(		(a = c and: [b = d]) or: [		(a > c and: [a < d]) or: [		(b > c and: [b < d]) or: [		(c > a and: [c < b]) or: [		(d > a and: [d < b]) ]]]]	)! !!Reservation methodsFor: 'comparing' stamp: 'KonstaS 12/14/2019 00:26'!isCurrent	(self end >= DateAndTime now)		ifTrue: [^true]		ifFalse: [^false].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Reservation class	instanceVariableNames: ''!!Reservation class methodsFor: 'instance creation' stamp: 'KonstaS 12/14/2019 13:25'!start: aStart end: anEnd	"Creates a Reservation object with start and end time"	^(self new start: aStart) end: anEnd! !Object subclass: #Role	instanceVariableNames: 'permissions myName'	classVariableNames: ''	poolDictionaries: ''	category: 'Reservations'!!Role commentStamp: 'KonstaS 12/14/2019 15:15' prior: 0!I specify permissions for users and a permission set.!!Role methodsFor: 'initialize-release' stamp: 'KonstaS 12/14/2019 11:16'!initialize	permissions := Bag new! !!Role methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 11:14'!givePermissionTo: aPermission	permissions add: aPermission! !!Role methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 11:16'!name: aSymbol	myName := aSymbol! !!Role methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 11:15'!hasPermissionTo: aPermission	^ (permissions includes: aPermission)! !!Role methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 11:15'!name	^myName! !Object subclass: #Room	instanceVariableNames: 'reservations isNoble name location capacity isLocked equipment'	classVariableNames: ''	poolDictionaries: ''	category: 'Reservations'!!Room commentStamp: 'KonstaS 12/14/2019 15:18' prior: 0!I am a room. I hold the room information: equipment, capacity, disponibility and status!!Room methodsFor: 'reservations' stamp: 'KonstaS 12/14/2019 10:55'!addReservation: aReservation	"add a reservation to this room." 		(aReservation room isNil)		ifTrue: [ aReservation room: self ].			(isNoble)		ifTrue: [ aReservation setPending ]		ifFalse: [ aReservation accept ].	(self doesNotHaveConflictingReservationWith: aReservation ) 		ifTrue: [ reservations add: aReservation. 			      ^ true ].      ^ false.! !!Room methodsFor: 'reservations' stamp: 'KonstaS 12/14/2019 10:56'!doesNotHaveConflictingReservationWith: aReservation	"Check whether the room has a conflicting reservation with aReservation"		reservations detect: [ :reservation | aReservation conflictsWith: reservation ]      	ifNone: [ ^ true ].	^ false.		! !!Room methodsFor: 'reservations' stamp: 'KonstaS 12/14/2019 10:44'!acceptAll	"authorize all reservations that are not already denied"		reservations do: [ :reservation | reservation isDenied												ifFalse: [ reservation accept] ]		! !!Room methodsFor: 'reservations' stamp: 'KonstaS 12/14/2019 10:55'!doesNotHaveConflictWithAList: aListOfReservations	"Check whether the room has a conflicting reservation with any reservation on the list"		aListOfReservations detect: [ :reservation | self hasConflictingReservationWith: reservation ]      	ifNone: [ ^ true ].	^ false.		! !!Room methodsFor: 'reservations' stamp: 'KonstaS 12/14/2019 10:55'!cancelReservation: aReservation	"Removes a reservation from its list of reservations"	reservations remove: aReservation! !!Room methodsFor: 'reservations' stamp: 'KonstaS 12/14/2019 10:57'!reservationsFor: aUser	"give a list of reservations by aUser"		^(reservations select: [ :reservation | (reservation user) = aUser]).		! !!Room methodsFor: 'reservations' stamp: 'KonstaS 12/14/2019 10:56'!hasNonDeniedReservationFor: aUser	"Check whether the room has a reservation by aUser"		reservations detect: [ :reservation | (reservation user) = aUser and: [(reservation isDenied) not]]      	ifNone: [ ^ false ].	^ true.		! !!Room methodsFor: 'reservations' stamp: 'KonstaS 12/14/2019 10:56'!hasConflictingReservationWith: aReservation	"Check whether the room has a conflicting reservation with aReservation"		^ ((self doesNotHaveConflictingReservationWith: aReservation) not)	! !!Room methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 10:33'!capacity	"Get the number of people the room can house"	^capacity! !!Room methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 10:35'!isNoble	"Whether this room is noble"	^isNoble! !!Room methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 10:35'!isLocked	"Whether this room is locked"	^isLocked! !!Room methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 10:37'!setLocked: aBoolean	"Mark a room as locked"	isLocked := aBoolean! !!Room methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 10:34'!capacity: aNumber	"Get the number of people the room can house"	capacity := aNumber! !!Room methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 10:37'!name: aName location: aLocation capacity: aCapacity	"required attributes"	name := aName.	location := aLocation.	capacity := aCapacity.	isNoble := false.	isLocked := false.! !!Room methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 10:35'!location		^location! !!Room methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 10:36'!name	^ name! !!Room methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 10:36'!location: aLocation		location := aLocation! !!Room methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 10:38'!setNoble: aBoolean	"Mark a room as noble"	isNoble := aBoolean! !!Room methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 10:37'!reservations	^ reservations! !!Room methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 10:34'!equipment	"Get all the room equipment"	^equipment! !!Room methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 10:34'!equipment: someEquipment	"Set all the room equipment"	equipment := someEquipment! !!Room methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 10:36'!name: anObject	name := anObject! !!Room methodsFor: 'initialize - release' stamp: 'KonstaS 12/14/2019 15:10'!initialize	      reservations := SortedCollection new.	isNoble := false.	isLocked := false.	equipment := 'monitor'.! !!Room methodsFor: 'copy' stamp: 'KonstaS 12/14/2019 10:39'!postCopy	" method to change the default behavior of copying"	super postCopy.	reservations := reservations copy.! !!Room methodsFor: 'private' stamp: 'KonstaS 12/14/2019 10:42'!reservationComplement: someReservations during: aTimespan	"Returns available periods during aTimespan based on reservations made in someReservations"		| start end freeTimespans |		freeTimespans := OrderedCollection new.	start := aTimespan start.	someReservations do: [ :reservation |		end := reservation start.		( start < end)			ifTrue: [ freeTimespans add: (Timespan starting: start ending: end) ].		start := reservation end ].		( start < aTimespan end)		ifTrue: [ freeTimespans add: ( Timespan starting: start ending: (aTimespan end) ) ].		^ freeTimespans! !!Room methodsFor: 'searching' stamp: 'KonstaS 12/14/2019 10:58'!getDisponibilityInTheWeekOf: aDateAndTime	"gives a list of times the room is available in a week. The week is given by a day that is inside it"	| reservationsDuringTheWeek sortedReservations weekReservationPeriod	week weekStart weekEnd |		week := aDateAndTime asWeek.	weekStart := week start.	weekEnd := weekStart + week duration.		weekReservationPeriod := Reservation	start: weekStart end: weekEnd. 	reservationsDuringTheWeek := reservations select: [ :reservation |		reservation conflictsWith: weekReservationPeriod ].	sortedReservations := reservationsDuringTheWeek asSortedCollection.		^ self reservationComplement: sortedReservations during: week! !!Room methodsFor: 'searching' stamp: 'KonstaS 12/14/2019 10:58'!getPendingReservations	"Returns all pending reservations"	^ (reservations select: [ :reservation | reservation isPending])! !!Room methodsFor: 'searching' stamp: 'KonstaS 12/14/2019 10:58'!getReservationsByEmail: anEmail		^ (reservations select: [ :reservation | anEmail = ((reservation user) email) ])! !!Room methodsFor: 'searching' stamp: 'KonstaS 12/14/2019 10:59'!getReservationsByUser: aUser		^ (reservations select: [ :reservation | aUser == reservation user ])! !!Room methodsFor: 'searching' stamp: 'KonstaS 12/14/2019 13:04'!getDisponibilityInADay: aDay	"gives a list of times the room is available in a given day"	| reservationsDuringTheDay sortedReservations dayReservationPeriod	dayStart dayEnd |		dayStart := aDay start.	dayEnd := dayStart + aDay duration.		dayReservationPeriod := Reservation	start: dayStart end: dayEnd. 	reservationsDuringTheDay := reservations select: [ :reservation |		reservation conflictsWith: dayReservationPeriod ].	sortedReservations := reservationsDuringTheDay asSortedCollection.		^ self reservationComplement: sortedReservations during: aDay.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Room class	instanceVariableNames: ''!!Room class methodsFor: 'class initialization' stamp: 'KonstaS 12/14/2019 13:27'!name: aName location: aLocation capacity: aCapacity	"creates a new room with required fields"      ^(self new)		name: aName		location: aLocation		capacity: aCapacity.	! !Object subclass: #Rooms	instanceVariableNames: 'rooms'	classVariableNames: ''	poolDictionaries: ''	category: 'Reservations'!!Rooms commentStamp: 'KonstaS 12/14/2019 15:19' prior: 0!I'm a list of all rooms. You could add and remove rooms to me and get room's information!!Rooms methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 11:20'!rooms		^ rooms! !!Rooms methodsFor: 'adding' stamp: 'KonstaS 12/14/2019 11:24'!addRoom: aRoom	rooms add: aRoom.! !!Rooms methodsFor: 'removing' stamp: 'KonstaS 12/14/2019 11:24'!removeRoom: aRoom	rooms remove: aRoom! !!Rooms methodsFor: 'searching' stamp: 'KonstaS 12/14/2019 11:25'!getPendingReservations	"The secretary should see a list of pending reservations from all rooms"	| pendingReservations |		pendingReservations := Bag new.	rooms do: [ :room | pendingReservations addAll: (room getPendingReservations) ].		^pendingReservations! !!Rooms methodsFor: 'searching' stamp: 'KonstaS 12/14/2019 11:26'!getReservationsByUser: aUser	"Returns all reservations by aUser of all rooms"	| reservations |		reservations := Bag new.	rooms do: [ :room | reservations addAll: (room getReservationsByUser: aUser) ].		^reservations! !!Rooms methodsFor: 'searching' stamp: 'KonstaS 12/14/2019 11:26'!getReservationsByEmail: anEmail	"Returns all reservations by aUser of all rooms"	| reservations |		reservations := Bag new.	rooms do: [ :room | reservations addAll: (room getReservationsByEmail: anEmail) ].		^reservations! !!Rooms methodsFor: 'initialize-release' stamp: 'KonstaS 12/14/2019 11:27'!initialize		rooms := SortedCollection sortBlock: [ :a :b | a name <= b name ].! !!Rooms methodsFor: 'validation' stamp: 'KonstaS 12/14/2019 11:26'!isRoomName: aRoomName takenByOtherThan: aRoom	" The room to compare with can be nil"		rooms detect: [ :room | room name = aRoomName and:  [ room ~= aRoom ] ]      	ifNone: [ ^ false ].	^ true.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Rooms class	instanceVariableNames: 'soleInstance'!!Rooms class methodsFor: 'class initialization' stamp: 'KonstaS 12/14/2019 13:30'!new	self error: 'cannot create new object'! !!Rooms class methodsFor: 'class initialization' stamp: 'KonstaS 12/14/2019 15:03'!clear	soleInstance := super new! !!Rooms class methodsFor: 'class initialization' stamp: 'KonstaS 12/14/2019 15:03'!default	soleInstance isNil ifTrue: [soleInstance := super new].	^ soleInstance! !Object subclass: #User	instanceVariableNames: 'name email password roles userContainer'	classVariableNames: ''	poolDictionaries: ''	category: 'Reservations'!!User commentStamp: 'KonstaS 12/14/2019 15:20' prior: 0!I'm a user. I hold  name, email and password and roleI help authenticate, and tell which user has what permission!!User methodsFor: 'copying' stamp: 'KonstaS 12/14/2019 15:26'!postCopy	"method to change the default behavior of copying"	super postCopy.	roles := roles copy.! !!User methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 11:36'!password: clearPassword	password := clearPassword! !!User methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 11:34'!email	"Simple getter"	^email! !!User methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 11:35'!name	"Simple getter"	^name! !!User methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 11:36'!password	^ password! !!User methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 11:35'!name: aName	"Simple setter"	name := aName! !!User methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 11:35'!email: anEmail	"Simple setter"	email := anEmail! !!User methodsFor: 'permissions' stamp: 'KonstaS 12/14/2019 15:07'!hasRole: aSymbol	^ (roles select: [ :role | role name = aSymbol ]) isNotEmpty! !!User methodsFor: 'permissions' stamp: 'KonstaS 12/14/2019 11:41'!addRole: aSymbol	roles add: (userContainer getRole: aSymbol). ! !!User methodsFor: 'permissions' stamp: 'KonstaS 12/14/2019 11:43'!removeRole: aSymbol	roles remove: (userContainer getRole: aSymbol) ifAbsent: []! !!User methodsFor: 'permissions' stamp: 'KonstaS 12/14/2019 11:42'!hasPermissionTo: aPermission	"comment stating purpose of message"	roles detect: [ :role | role hasPermissionTo: aPermission ]		ifNone: [ ^false ].	^true! !!User methodsFor: 'initialize - release' stamp: 'KonstaS 12/14/2019 11:40'!initialize       roles := Set new.	userContainer := Users default.! !!User methodsFor: 'roles-dependent' stamp: 'KonstaS 12/14/2019 11:44'!helperRole: aRoleSymbol value: aBoolean		aBoolean		ifTrue: [ self addRole: aRoleSymbol ]		ifFalse: [self removeRole: aRoleSymbol ].! !!User methodsFor: 'roles-dependent' stamp: 'KonstaS 12/14/2019 11:44'!admin: aBoolean	 	self helperRole: #admin value: aBoolean! !!User methodsFor: 'roles-dependent' stamp: 'KonstaS 12/14/2019 11:44'!secretary		^ self hasRole: #secretary.! !!User methodsFor: 'roles-dependent' stamp: 'KonstaS 12/14/2019 11:44'!secretary: aBoolean		self helperRole: #secretary value: aBoolean! !!User methodsFor: 'roles-dependent' stamp: 'KonstaS 12/14/2019 11:43'!admin		^ self hasRole: #admin.! !Object subclass: #Users	instanceVariableNames: 'roles users roomContainer'	classVariableNames: ''	poolDictionaries: ''	category: 'Reservations'!!Users commentStamp: 'KonstaS 12/14/2019 11:40' prior: 0!I have the list of users and the list of permissions.!!Users methodsFor: 'removing' stamp: 'KonstaS 12/14/2019 11:54'!removeUser: aUser	users remove: aUser! !!Users methodsFor: 'initialize - release' stamp: 'KonstaS 12/14/2019 15:30'!initializeDefaultUsers	"Very first users"	| admin secretary user |	admin := User new.	admin email: 'super@ahvenbooking.com'.	admin password: 'nNJg#%46tFf'.	admin addRole: #admin.	self addUser: admin.		secretary := User new.	secretary email: 'inbox@ahvenbooking.com'.	secretary password: '12345678'.	secretary addRole: #secretary.	self addUser: secretary.		user := User new.	user email: 'it@ahvenbooking.com'.	user password: '87654321'.	self addUser: user.! !!Users methodsFor: 'initialize - release' stamp: 'KonstaS 12/14/2019 11:51'!initialize	self initializeRoles.	users := SortedCollection sortBlock: [ :a :b | a email <= b email ].	roomContainer := Rooms default.! !!Users methodsFor: 'initialize - release' stamp: 'KonstaS 12/14/2019 11:52'!initializeRoles	| admin secretary user |	admin := Role new.	admin givePermissionTo: #manageUsers;		givePermissionTo: #manageRooms.	admin name: #admin.		secretary := Role new.	secretary givePermissionTo: #authorizeReservations.	secretary name: #secretary.		user := Role new.	user givePermissionTo: #doUserActions.	user name: #user.		roles := Bag with: admin				  with: secretary				  with: user.! !!Users methodsFor: 'private' stamp: 'KonstaS 12/14/2019 11:53'!getRole: aSymbol		^ (roles select: [:role | role name = aSymbol]) asOrderedCollection first! !!Users methodsFor: 'adding' stamp: 'KonstaS 12/14/2019 11:50'!addUser: aUser	"It is our job not to add duplicated objects	if the user once existed, his reservations are still on the system, and we give then back"	aUser addRole: #user.	users add: aUser.	(roomContainer  getReservationsByEmail: (aUser email)) do: [:reservation| (((reservation user) email) = (aUser email))																		ifTrue: [reservation user: aUser]]! !!Users methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 11:49'!returnUserWithTheSameEmailAs: aId	"return user with the given id (i.e. email)"	|rightUser ordered| 	rightUser := (users select: [ :user |		user email = aId email ]).	ordered := rightUser asOrderedCollection.	^ (ordered first)! !!Users methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 11:48'!numberOfUsers		^ (users size)! !!Users methodsFor: 'accessing' stamp: 'KonstaS 12/14/2019 11:49'!users		^ users! !!Users methodsFor: 'validation' stamp: 'KonstaS 12/14/2019 11:54'!canLogin: aUser	"Checks if user is registered and if password matches"	users detect: [ :user |		user email = aUser email and:		[ user password = aUser password ]]		ifNone: [ ^ false ].	^ true! !!Users methodsFor: 'validation' stamp: 'KonstaS 12/14/2019 11:55'!isEmail: anEmail takenByOtherThan: aUser	" The user to compare with can be nil"		users detect: [ :user | user email = anEmail and: [ user ~= aUser ] ]      	ifNone: [ ^ false ].	^ true	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Users class	instanceVariableNames: 'soleInstance defaultUsersInitialized'!!Users class methodsFor: 'class initialization' stamp: 'KonstaS 12/14/2019 13:42'!new	self error: 'cannot create new object'! !!Users class methodsFor: 'class initialization' stamp: 'KonstaS 12/14/2019 15:04'!clear	soleInstance := nil.	defaultUsersInitialized := nil.! !!Users class methodsFor: 'class initialization' stamp: 'KonstaS 12/14/2019 15:04'!default	"I cant create users if a user called: My users would again try to create me!!"	soleInstance isNil ifTrue: [soleInstance := super new].	(((thisContext client) class) = User)		ifFalse: [ 	defaultUsersInitialized isNil						ifTrue: [soleInstance initializeDefaultUsers.				 	 			  defaultUsersInitialized := true]].	^ soleInstance! !